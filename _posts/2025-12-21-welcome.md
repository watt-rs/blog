---
title: Introducing Watt âš¡
date: 2025-12-21 20:00:00 +/-1000
categories: [docs, new]
tags: [info]

---

## ğŸ‘‹ Welcome to Watt

Hi there! If you like the idea of languages that **help you think**, not fight you â€” you might enjoy Watt.

**Watt** is a friendly, strongly typed functional programming language written in **Rust**. Its goal is simple but ambitious: make functional programming practical, readable, and approachable for everyday development, especially for the web.

Watt has no hidden magic. Instead, it offers:

- âŒ `null` â€” because absence of a value should be explicit  
- âŒ unchecked exceptions â€” errors must be handled or declared  
- âœ… clear error messages  
- âœ… a practical, predictable type system  
- âœ… pattern matching that reads like normal code  

Watt encourages good design: state is expressed in types, logic is verified by the compiler, not just by comments.

> âš ï¸ **Status:** Watt is a work in progress. Syntax and features may change.

---

## ğŸ§¬ Algebraic Data Types (ADT)

ADT is one of the core building blocks of Watt. You can model real-world concepts directly and safely.

```watt
enum Iceberg {  
    Large(size: float, mammoth: Mammoth),  
    Small(size: float)  
}  

type Mammoth {  
    age: int,  
    name: string  
}  

*Here you see how to combine different types safely, like building blocks for your data.*
```

---

## ğŸ§  Logical expressions

```watt
type Rex {  
    age: int  
}  

fn is_ancient(r: Rex): bool {  
    if r.age > 10000 {  
        true  
    } else {  
        false  
    }  
}  
```
*An example of clear, readable conditionals â€” the compiler helps you get it right.*

---

## ğŸ¦œ Loops and ranges

```watt
use std/io as io  

type Parrot {  
    name: string  
}  

fn repeat(p: Parrot) {  
    for i in 0..3 {  
        io.println(p.name <> " says: hello!")  
    }  
}
```

*Looping made simple, showing how to repeat actions safely. No break or continue keywords!*

---

## ğŸ Enums & pattern matching

```watt
enum Snake {  
    Python(length: int),  
    Boa(length: int)  
}  

fn description(s: Snake): string =  
    match s {  
        Snake.Python(length) -> "Python, length " <> length  
        Snake.Boa(length)    -> "Boa, length " <> length  
    }  
```

*Every case is handled explicitly â€” no surprises at runtime.*

---

## ğŸ“¡ Communication example: Satellite & Dish

```watt
enum Signal {  
    Ok(strength: int),  
    Lost  
}  

type Dish {  
    angle: int  
}  

fn receive(d: Dish): Signal {  
    if d.angle == 42 {  
        Signal.Ok(100)  
    } else {  
        Signal.Lost  
    }  
}
```

*Example of how you can represent different states of a signal safely.*

---

## ğŸ›°ï¸ Pattern matching with a satellite

```watt
fn status(s: Signal): string =  
    match s {  
        Signal.Ok(power) -> "Signal received, power " <> power  
        Signal.Lost      -> "No signal"  
    }
```

*Handling all possible outcomes cleanly â€” the compiler ensures nothing is forgotten.*

---

## ğŸ„ A playful example: Mushrooms

```watt
enum Mushroom {  
    Edible,  
    Poisonous  
}  

fn eat(m: Mushroom): string =  
    match m {  
        Mushroom.Edible    -> "Tasty and safe"  
        Mushroom.Poisonous -> "Bad idea"  
    }
```

*Using enums to make decisions safe and obvious, even for mushrooms!*

---

## ğŸ”¦ Infinite loops with exit conditions

```watt
use std/io as io  

type Flashlight {  
    power: int  
}  

fn shine(f: Flashlight) {  
    loop {  
        if f.power == 0 {  
            io.println("The light went out")  
            return  
        }  

        io.println("Light power: " <> f.power)  
        f.power = f.power - 1  
    }  
}  
```

*A practical loop with a clear stop condition â€” no accidental infinite loops.*

---

## ğŸ“ Calling external JavaScript

```watt
extern fn clamp(x: int): int = `  
    if (x < 0) return 0;  
    if (x > 100) return 100;  
    return x;  
`  

fn lantern_power(raw: int): int {  
    clamp(raw)  
}
```

*Interop made safe and straightforward.*

---

## ğŸ§­ Panic & todo

```watt
type Explorer {
  name: string,
  fossils: int
}  

fn explore(e: Explorer) {  
    if e.fossils == 0 { panic "No fossils!" }  
    elif e.fossils < 0 { panic }  
    elif e.fossils < 5 { todo as "Find more fossils" }  
    else { io.println(e.name <> " found many fossils!") }  
}  
```

*Explicit errors and reminders help you catch problems early.*

---

## ğŸ“¦ Generics

```watt
enum Option[T] {  
    Some(value: T),  
    None  
}  

type Box[T] {  
    value: T  
}  
```

*Reusable building blocks for any type you can imagine.*

---

## ğŸ§  Proposal: Why Watt exists

### ğŸ§© How types help you make fewer mistakes

Types in Watt **encode intent directly**. Functions and enums force handling all states, making certain bugs impossible.

### ğŸ¤ The compiler is your friend

Compile-time checks guide you to correct logic. Mistakes are caught early, not in production.

### ğŸŒ Why functional programming for the web?

FP ideas like pure functions, immutable data, and explicit state help manage complex web systems safely and clearly.

### ğŸ” Safety as a consequence of design

No `null`, explicit states, strong types: Watt prevents unsafe states from ever existing.

### ğŸ†š How Watt differs from TypeScript

TypeScript allows invalid states (optional properties, `any`, etc.). Watt **prevents them entirely**.

---

## ğŸ¯ Design principles

1. Make illegal states unrepresentable  
2. Explicit is better than implicit  
3. The language should help you think  
4. Practical over theoretical  
5. Friendly by default  

---

## ğŸš« Non-goals

Watt does **not** try to:  

- be a drop-in replacement for JS/TS  
- allow unrestricted dynamic behavior  
- support implicit null-like values  
- provide endless escape hatches  
- prioritize short-term convenience over correctness  

---

## ğŸ‘¥ Who Watt is for (and who it isnâ€™t)

**For you if**:  

- enjoy strong, expressive types  
- want compiler checks to catch mistakes  
- build web/networked systems with complex state  
- like FP but practical  
- value clarity and safety  

**Not for you if**:  

- need unrestricted dynamic behavior  
- rely on runtime reflection/metaprogramming  
- prefer minimal typing and max freedom  
- want a JS drop-in replacement  

Watt is opinionated â€” and intentionally so. It serves developers who value **correctness, readability, and long-term maintainability**.

---

## ğŸ§ª TypeScript vs Watt: a small but real example

### TypeScript

```typescript
type Response = {  
  status: "ok" | "error"  
  data?: string  
}  

function handle(r: Response) {  
  if (r.status === "ok") {  
    console.log(r.data.toUpperCase()) // may crash if data is undefined  
  }  
}
```

### Watt

```watt
enum Response {  
    Ok(data: string),  
    Error  
}  

fn handle(r: Response) {  
    match r {  
        Response.Ok(data) -> io.println(data.to_upper())  
        Response.Error   -> io.println("Something went wrong")  
    }  
}  
```

*TypeScript lets you get tripped up â€” Watt keeps it safe from the start.*

---

## ğŸš€ Whatâ€™s next?

Watt is evolving, but the direction is clear:  

- strong, understandable types  
- minimal magic  
- maximum readability  

If you believe a language should **help you write correct code**, not fight you â€” welcome.  
The story of Watt is just beginning.

